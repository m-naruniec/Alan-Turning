-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParTurning where
import AbsTurning
import LexTurning
import ErrM

}

%name pProg Prog
%name pDecl Decl
%name pDecl1 Decl1
%name pParam Param
%name pListParam ListParam
%name pType Type
%name pStmt Stmt
%name pStmt1 Stmt1
%name pArg Arg
%name pListArg ListArg
%name pExp Exp
%name pOpAss OpAss
%name pExp1 Exp1
%name pExp2 Exp2
%name pExp3 Exp3
%name pOpComp OpComp
%name pExp4 Exp4
%name pOpOrd OpOrd
%name pExp5 Exp5
%name pOpAdd OpAdd
%name pExp6 Exp6
%name pOpMul OpMul
%name pExp7 Exp7
%name pOpInv OpInv
%name pExp8 Exp8
%name pOpPrePost OpPrePost
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '%=' { PT _ (TS _ 4) }
  '&&' { PT _ (TS _ 5) }
  '(' { PT _ (TS _ 6) }
  ')' { PT _ (TS _ 7) }
  '*' { PT _ (TS _ 8) }
  '*=' { PT _ (TS _ 9) }
  '+' { PT _ (TS _ 10) }
  '++' { PT _ (TS _ 11) }
  '+=' { PT _ (TS _ 12) }
  ',' { PT _ (TS _ 13) }
  '-' { PT _ (TS _ 14) }
  '--' { PT _ (TS _ 15) }
  '-=' { PT _ (TS _ 16) }
  '/' { PT _ (TS _ 17) }
  '/=' { PT _ (TS _ 18) }
  ':' { PT _ (TS _ 19) }
  ';' { PT _ (TS _ 20) }
  '<' { PT _ (TS _ 21) }
  '<=' { PT _ (TS _ 22) }
  '=' { PT _ (TS _ 23) }
  '==' { PT _ (TS _ 24) }
  '>' { PT _ (TS _ 25) }
  '>=' { PT _ (TS _ 26) }
  '?' { PT _ (TS _ 27) }
  'False' { PT _ (TS _ 28) }
  'True' { PT _ (TS _ 29) }
  'bool' { PT _ (TS _ 30) }
  'else' { PT _ (TS _ 31) }
  'if' { PT _ (TS _ 32) }
  'int' { PT _ (TS _ 33) }
  'left' { PT _ (TS _ 34) }
  'print' { PT _ (TS _ 35) }
  'proc' { PT _ (TS _ 36) }
  'ref' { PT _ (TS _ 37) }
  'right' { PT _ (TS _ 38) }
  'skip' { PT _ (TS _ 39) }
  'turn' { PT _ (TS _ 40) }
  '{' { PT _ (TS _ 41) }
  '||' { PT _ (TS _ 42) }
  '}' { PT _ (TS _ 43) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }

Prog :: { Prog }
Prog : Stmt { AbsTurning.Prog $1 }
     | Stmt ';' { AbsTurning.Prog $1 }
Decl :: { Decl }
Decl : Decl ';' Decl1 { AbsTurning.DSeq $1 $3 } | Decl1 { $1 }
Decl1 :: { Decl }
Decl1 : Type Ident { AbsTurning.DDflt $1 $2 }
      | Type Ident '=' Exp { AbsTurning.DVal $1 $2 $4 }
      | 'proc' Ident '(' ListParam ')' '{' Stmt ';' '}' { AbsTurning.DProc $2 $4 $7 }
      | '(' Decl ')' { $2 }
Param :: { Param }
Param : Type Ident { AbsTurning.Param $1 $2 }
ListParam :: { [Param] }
ListParam : {- empty -} { [] }
          | Param { (:[]) $1 }
          | Param ',' ListParam { (:) $1 $3 }
Type :: { Type }
Type : 'int' { AbsTurning.TInt } | 'bool' { AbsTurning.TBool }
Stmt :: { Stmt }
Stmt : Stmt ';' Stmt1 { AbsTurning.SSeq $1 $3 } | Stmt1 { $1 }
Stmt1 :: { Stmt }
Stmt1 : 'left' Stmt1 { AbsTurning.SLeft $2 }
      | 'right' Stmt1 { AbsTurning.SRight $2 }
      | 'skip' { AbsTurning.SSkip }
      | 'if' '(' Exp ')' '{' Stmt ';' '}' { AbsTurning.SIf $3 $6 }
      | 'if' '(' Exp ')' '{' Stmt ';' '}' 'else' '{' Stmt ';' '}' { AbsTurning.SIfte $3 $6 $11 }
      | 'turn' { AbsTurning.STurn }
      | Exp { AbsTurning.SExp $1 }
      | 'print' Exp { AbsTurning.SPrint $2 }
      | '{' Decl ';' ':' Stmt ';' '}' { AbsTurning.SBlock $2 $5 }
      | Ident '(' ListArg ')' { AbsTurning.SProc $1 $3 }
      | '(' Stmt ')' { $2 }
Arg :: { Arg }
Arg : Exp { AbsTurning.AVal $1 }
    | 'ref' Ident { AbsTurning.ARef $2 }
ListArg :: { [Arg] }
ListArg : {- empty -} { [] }
        | Arg { (:[]) $1 }
        | Arg ',' ListArg { (:) $1 $3 }
Exp :: { Exp }
Exp : Ident OpAss Exp { AbsTurning.EAss $1 $2 $3 }
    | Exp1 '?' Exp ':' Exp1 { AbsTurning.EIfte $1 $3 $5 }
    | Exp1 { $1 }
OpAss :: { OpAss }
OpAss : '=' { AbsTurning.OpAss }
      | '+=' { AbsTurning.OpAddAss }
      | '-=' { AbsTurning.OpSubAss }
      | '*=' { AbsTurning.OpMulAss }
      | '/=' { AbsTurning.OpDivAss }
      | '%=' { AbsTurning.OpModAss }
Exp1 :: { Exp }
Exp1 : Exp1 '||' Exp2 { AbsTurning.EOr $1 $3 } | Exp2 { $1 }
Exp2 :: { Exp }
Exp2 : Exp2 '&&' Exp3 { AbsTurning.EAnd $1 $3 } | Exp3 { $1 }
Exp3 :: { Exp }
Exp3 : Exp3 OpComp Exp4 { AbsTurning.EComp $1 $2 $3 } | Exp4 { $1 }
OpComp :: { OpComp }
OpComp : '==' { AbsTurning.OpEq } | '!=' { AbsTurning.OpNEq }
Exp4 :: { Exp }
Exp4 : Exp4 OpOrd Exp5 { AbsTurning.EOrd $1 $2 $3 } | Exp5 { $1 }
OpOrd :: { OpOrd }
OpOrd : '<' { AbsTurning.OpLT }
      | '<=' { AbsTurning.OpLEq }
      | '>' { AbsTurning.OpGT }
      | '>=' { AbsTurning.OpGEq }
Exp5 :: { Exp }
Exp5 : Exp5 OpAdd Exp6 { AbsTurning.EAdd $1 $2 $3 } | Exp6 { $1 }
OpAdd :: { OpAdd }
OpAdd : '+' { AbsTurning.OpPlus } | '-' { AbsTurning.OpMinus }
Exp6 :: { Exp }
Exp6 : Exp6 OpMul Exp7 { AbsTurning.EMul $1 $2 $3 } | Exp7 { $1 }
OpMul :: { OpMul }
OpMul : '*' { AbsTurning.OpTimes }
      | '/' { AbsTurning.OpDiv }
      | '%' { AbsTurning.OpMod }
Exp7 :: { Exp }
Exp7 : OpInv Exp8 { AbsTurning.EInv $1 $2 } | Exp8 { $1 }
OpInv :: { OpInv }
OpInv : '!' { AbsTurning.OpNot } | '-' { AbsTurning.OpNeg }
Exp8 :: { Exp }
Exp8 : Ident { AbsTurning.EVar $1 }
     | Integer { AbsTurning.EInt $1 }
     | 'True' { AbsTurning.ETrue }
     | 'False' { AbsTurning.EFalse }
     | OpPrePost Ident { AbsTurning.EPreOp $1 $2 }
     | Ident OpPrePost { AbsTurning.EPostOp $1 $2 }
     | '(' Exp ')' { $2 }
OpPrePost :: { OpPrePost }
OpPrePost : '++' { AbsTurning.OpInc } | '--' { AbsTurning.OpDec }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

